CVE-2018-0893: Microsoft Edge Scripting Engine Memory Corruption Vulnerability

There is a vulnerability in Edge's DOM accessor functions, such as DOMFastPath<T>::EntrySimpleSlotGetter. The templated code of getters fails to sanitize the `this` value of the Javascript execution context, which may be user controlled via .call or .apply. This leads to a type confusion, where a user-provided value is treated as a pointer to a Javascript object. The type confusion has security implications, and can possibly be leveraged into a number of exploitable conditions.

***

Minimal test-case is as follows:

var o = window.__lookupGetter__('event').call(0x42424242 >> 1)  // crash at 0x42424247 on a 32-bit system

Tested on Windows 10 RS3 x64/x32, Nov.2017

***

The crash happens when Chakra dereferences the user-provided pointer value in order to determine the `this` object's type via chakra!Js::JavascriptTypedObjectSlotAccessorFunction::InstanceOf:

  (d44.102c): Access violation - code c0000005 (!!! second chance !!!)
  eax=00000003 ebx=0867cb80 ecx=0867cb80 edx=42424243 esi=000011f6 edi=04efcdf0
  eip=5c5512f5 esp=04efcd44 ebp=04efcd50 iopl=0         nv up ei ng nz ac po cy
  cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00210293
  chakra!Js::JavascriptTypedObjectSlotAccessorFunction::InstanceOf+0x23:
  5c5512f5 8b7a04          mov     edi,dword ptr [edx+4] ds:0023:42424247=????????
  0:009> kb
   # ChildEBP RetAddr  Args to Child
  00 04efcd50 5c677e28 42424243 04efcd88 04efcd78 chakra!Js::JavascriptTypedObjectSlotAccessorFunction::InstanceOf+0x23
  01 04efcd60 5c414c54 42424243 00000001 02000001 chakra!Js::JavascriptTypedObjectSlotAccessorFunction::ValidateThisInstance+0xe
  02 04efcd78 5c5971b1 0867cb80 02000001 42424243 chakra!DOMFastPath<7>::EntrySimpleSlotGetter+0x54
  03 04efcdc0 5c4f95da 02000001 04efcdf0 00000002 chakra!Js::JavascriptFunction::CallFunction<1>+0x91
  04 04efcde0 5c4c27a0 0867d0c0 02000002 42424243 chakra!Js::JavascriptFunction::EntryCall+0xaa
  05 04efce30 5c4c5167 0887a055 0867d0c0 00000000 chakra!Js::InterpreterStackFrame::OP_CallCommon<Js::OpLayoutDynamicProfile<Js::OpLayoutT_CallI<Js::LayoutSizePolicy<0> > > >+0xd0
  06 04efce68 5c4c8ab1 0887a055 04efcfac 08890000 chakra!Js::InterpreterStackFrame::OP_ProfiledCallIWithICIndex<Js::OpLayoutT_CallIWithICIndex<Js::LayoutSizePolicy<0> > >+0x77
  07 04efcea0 5c4c6ecd b80b6763 04efcee0 047161b0 chakra!Js::InterpreterStackFrame::ProcessProfiled+0x101
  08 04efced8 5c4caaa2 0887a000 0887a05e 00000000 chakra!Js::InterpreterStackFrame::Process+0x10d
  09 04efd088 5c4cbc38 04efd0b8 00000000 00000000 chakra!Js::InterpreterStackFrame::InterpreterHelper+0x3c2
  0a 04efd0b4 088b0fe2 04efd0c8 04efd104 5c5971b1 chakra!Js::InterpreterStackFrame::InterpreterThunk+0x38
...

The reason is that in ChakraCore, JavascriptTypedObjectSlotAccessorFunction::InstanceOf fails to check whether the thisObj is actually an object pointer, and proceeds to call JavascriptOperators::GetTypeId on it, which in turn casts it to RecyclableObject and proceeds to dereference without any checks:

    bool JavascriptTypedObjectSlotAccessorFunction::InstanceOf(Var thisObj)
    {
        int allowedTypeId = GetAllowedTypeId();
        TypeId typeId = Js::JavascriptOperators::GetTypeId(thisObj); <<<<<<<  -> RecyclableObject::FromVar(aValue) -> this->GetType()->GetTypeId();
        if (typeId == allowedTypeId)
        {        
          ...
    }

Note that EntrySimpleSlotGetter actually tries to validate the `this` instance via ::ValidateThisInstance, however it only validates if it's of an allowed type, and not that it's actually a valid pointer.

The actual type confusion happens down in the stack, in JavascriptFunction::EntryCall: 

    Var JavascriptFunction::EntryCall(RecyclableObject* function, CallInfo callInfo, ...)
    {
        ...
        RecyclableObject *pFunc = RecyclableObject::FromVar(args[0]);
        if (argCount == 1)
        {
            args.Values[0] = scriptContext->GetLibrary()->GetUndefined();
        }
        else  <<<<<<<<<<<< the `this` (args[1]) should be sanitized before this, as downstream funcs don't assume a custom `this`
        { 
            ///
            /// Remove function object from the arguments and pass the rest
            ///
            for (uint i = 0; i < args.Info.Count - 1; ++i)  
            {
                args.Values[i] = args.Values[i + 1];
            }
            args.Info.Count = args.Info.Count - 1;
        }

        ///
        /// Call the [[Call]] method on the function object
        ///
        return JavascriptFunction::CallFunction<true>(pFunc, pFunc->GetEntryPoint(), args);
    }

Since the root cause is down in the stack, there may exist (or may be added in the future) other ways to reach the vulnerable code path, other than via DOM getters. 

***

Below I am providing a brief theoretical analysis of possible security implications of this bug.

1. Remote code execution

Normally, EntrySimpleSlotGetter would obtain a property pointer from the `this` memory address, and cast it back to the Javascript context:

.text:10134A0C loc_10134A0C:                           ; CODE XREF: DOMFastPath<8>::EntrySimpleSlotGetter(Js::RecyclableObject *,Js::CallInfo,...)+56j
.text:10134A0C                 mov     eax, [esi] 
.text:10134A0E                 mov     eax, [eax+38h]

That might allow for direct code execution via eg. returnedObject.someFunction().
However in this particular case, it fails half way through due to the Tagged Integer check in ::InstanceOf -> JsVarToExtension(). 

Since the root cause is actually down in the stack, remote code executaion remains a possiblity. 

2. Info leak

In EntrySimpleSlotGetter there is a code path that will throw a TypeError instead of crashing, in case that it finds a particular shape at the `this` memory address (eg. an object of an unsupported type). This can be leveraged as a signaling channel allowing determine the state of the heap, eg. if a heap spray was successful and/or if there exists a Javascript object at the provided memory location. 

Proof-of-concept: poc-typeerror.html

Note that, since Edge tabs crash silently, an attacker has infinite number of tries to probe the heap layout.

3. Security bypass / breach of standards

Due to dysfunctional type checks, this issue can in theory be used to retrieve a Javascript DOM object/property which we shouldn't have access to, or bypass Same Origin Policy for example. In addition, there may be subtle implications in the context of garbage collection, if we can obtain a reference to an object/property that we don't own, which can interfere with rooting/marking and possibly lead to a use-after-free.