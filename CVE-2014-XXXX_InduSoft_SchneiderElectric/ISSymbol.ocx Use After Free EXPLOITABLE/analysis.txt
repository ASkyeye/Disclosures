Software: Indusoft Web Studio Viewer 4.1.2.4
Module: issymbol.ocx
Type of vulnerability: Use after free / Double free

	Analysis

First of all, the vulnerability is caught by the target software's runtime environment, which leads to a software-controlled crash dump. But in reality no exception is handled and thus we can probably control the crash. 

Stack upon trigger:

0:000> kbChildEBP RetAddr  Args to Child              WARNING: Frame IP not in any known module. Following frames may be wrong.0012ba04 5f161eef 00000001 5f161fe4 103f6258 0x69206e750012ba0c 5f161fe4 103f6258 0012bb20 10260e83 mfc90u!CException::Delete+0xd0012ba18 10260e83 98c4f0f4 00000008 0000000f mfc90u!AfxTryCleanup+0x1d0012bb2c 10261cf9 0012bf14 98c48888 0012ba74 ISSymbol!DllUnregisterServer+0x2570230012c350 1028a0fa 0012d10c 98c48878 00000008 ISSymbol!DllUnregisterServer+0x257e990012c3a0 10031f70 0012d10c 00000001 98c4998c ISSymbol!DllUnregisterServer+0x28029a0012d254 10025fdd 0a112b50 00000000 10392134 ISSymbol!DllUnregisterServer+0x281100012d2ec 1002ff68 0a0cdcd0 80000000 80000000 ISSymbol!DllUnregisterServer+0x1c17d0012d9d8 10022136 0a0c84d8 98c4bbd8 00000000 ISSymbol!DllUnregisterServer+0x261080012f000 1001bfd2 98c4bf10 00003bf8 0012f04c ISSymbol!DllUnregisterServer+0x182d60012f4c8 1003f68d 00000000 98c4b2f4 0012f4ec ISSymbol!DllUnregisterServer+0x121720012f92c 5f1e2927 00332dbc 5f1cfd23 c7e3228a ISSymbol!DllUnregisterServer+0x3582d0012f9dc 5f1d03f0 10395008 00000001 00000000 mfc90u!_AfxDispatchCall+0x100012fa80 5f1d11d6 00000001 00000060 5f115f88 mfc90u!COleDispatchImpl::Invoke+0x3880012fb54 5f1eee36 00000060 00000001 00000000 mfc90u!COleDispatchDriver::InvokeHelperV+0x3240012fb7c 5f19c7d6 00000060 00000001 00000000 mfc90u!COleControlSite::InvokeHelperV+0x570012fb9c 004021f1 0002ff10 00000060 00000001 mfc90u!CWnd::InvokeHelper+0x270012fbc4 0040d047 01321cf0 0002c2c0 0002c1c0 Viewer+0x21f10012fbdc 0040d0f4 0002c1c0 0012fc90 5f16fafa Viewer+0xd0470012fbe8 5f16fafa 00000064 98c5cf12 00000113 Viewer+0xd0f40012fc90 5f16f6cc 00000113 00000064 00000000 mfc90u!CWnd::OnWndMsg+0x4070012fcb0 0040a36c 00000113 00000064 00000000 mfc90u!CWnd::WindowProc+0x240012fcc8 5f16e2f2 00000113 00000064 00000000 Viewer+0xa36c0012fd30 5f16e57e 00000000 001b04ac 00000113 mfc90u!AfxCallWndProc+0xa30012fd54 5f16c234 001b04ac 00000113 00000064 mfc90u!AfxWndProc+0x370012fd9c 76fcc4e7 001b04ac 00000113 00000064 mfc90u!AfxWndProcBase+0x560012fdc8 76fcc5e7 5f16c1de 001b04ac 00000113 USER32!InternalCallWinProc+0x230012fe40 76fccc19 0028912c 5f16c1de 001b04ac USER32!UserCallWinProcCheckWow+0x14b0012fea0 76fccc70 5f16c1de 00000000 0012fee0 USER32!DispatchMessageWorker+0x35e0012feb0 5f1ae491 002851e8 00000000 0041c6d0 USER32!DispatchMessageW+0xf0012fec0 5f1aeb18 0041c6d0 0041c6d0 ffffffff mfc90u!AfxInternalPumpMessage+0x400012fee0 5f17af81 0041c818 00000001 00000000 mfc90u!CWinThread::Run+0x5b0012fef4 0040507f 00400000 00000000 00271e56 mfc90u!AfxWinMain+0x6a0012ff88 7726ee1c 7ffd8000 0012ffd4 773637eb Viewer+0x507f0012ff94 773637eb 7ffd8000 4a2608df 00000000 kernel32!BaseThreadInitThunk+0xe0012ffd4 773637be 004051ee 7ffd8000 00000000 ntdll!__RtlUserThreadStart+0x700012ffec 00000000 004051ee 7ffd8000 00000000 ntdll!_RtlUserThreadStart+0x1b

This is the control transfer:

0:000> u mfc90u!CException::Deletemfc90u!CException::Delete:5f161ee2 83790400        cmp     dword ptr [ecx+4],05f161ee6 7e07            jle     mfc90u!CException::Delete+0xd (5f161eef)5f161ee8 8b01            mov     eax,dword ptr [ecx]5f161eea 6a01            push    15f161eec ff5004          call    dword ptr [eax+4] <-- CRASH5f161eef c3              ret

The control is transferred into arbitrary memory within mfc90u.dll module:

0:000> db poi(ecx)5f110062  62 65 20 72 75 6e 20 69-6e 20 44 4f 53 20 6d 6f  be run in DOS mo5f110072  64 65 2e 0d 0d 0a 24 00-00 00 00 00 00 00 d8 db  de....$.........5f110082  19 50 9c ba 77 03 9c ba-77 03 9c ba 77 03 bb 7c  .P..w...w...w..|5f110092  19 03 9d ba 77 03 02 9a-54 03 9d ba 77 03 bb 7c  ....w...T...w..|5f1100a2  1a 03 8d ba 77 03 95 c2-e4 03 9e ba 77 03 21 f5  ....w.......w.!.5f1100b2  e1 03 9d ba 77 03 95 c2-e2 03 97 ba 77 03 95 c2  ....w.......w...5f1100c2  f4 03 bc ba 77 03 95 c2-f3 03 97 ba 77 03 bb 7c  ....w.......w..|5f1100d2  0c 03 91 ba 77 03 9c ba-76 03 42 b9 77 03 95 c2  ....w...v.B.w...

The vuln itself seems to reside in the following code (ret to ISSymbol!DllUnregisterServer+0x257e99), in which CException::Delete() is called directly first, and then it's called again (on the already freed CException object) from internals of the AfxTryCleanup() function:

ISSymbol!DllUnregisterServer+0x256d00:
.text:10260B60 v2_257e99_256d00 proc near              ; CODE XREF: sub_10039050+35Ep.text:10260B60                                         ; sub_10039050+431p ....text:10260B60
....text:10260E2C loc_10260E2C:                           ; CODE XREF: v2_257e99_256d00+2D9j.text:10260E2C                 mov     ecx, [ebp+var_A0]
!!:.text:10260E32                 call    mfc90u_CException__Delete ; 1st call to CException::Delete .text:10260E37                 xor     ecx, ecx.text:10260E39                 jnz     short loc_10260E2C.text:10260E3B                 call    ds:GetTickCount.text:10260E41                 mov     edx, [ebp+var_DC].text:10260E47                 mov     [edx+0AF8h], eax.text:10260E4D                 mov     [ebp+var_B8], 0.text:10260E57                 mov     [ebp+var_4], 8.text:10260E5E                 mov     eax, offset loc_10260E7A ; called via CxxExceptionFilter()'s JumpToContiunation().text:10260E63                 retn[skip].text:10260E7A.text:10260E7A loc_10260E7A:                           ; DATA XREF: v2_257e99_256d00+2FEo.text:10260E7A                 mov     byte ptr [ebp+var_4], 3
!!:.text:10260E7E                 call    mfc90u_AfxTryCleanup ; 2nd call to CException::Delete (CRASH).text:10260E83                 mov     byte ptr [ebp+var_4], 2.text:10260E87                 lea     ecx, [ebp+var_60].text:10260E8A                 call    CArchive_constructor.text:10260E8F                 mov     byte ptr [ebp+var_4], 1.text:10260E93                 lea     ecx, [ebp+var_88].text:10260E99                 call    mfc90u_CMemFile___CMemFile.text:10260E9E                 mov     byte ptr [ebp+var_4], 0.text:10260EA2                 lea     ecx, [ebp+var_8C].text:10260EA8                 call    ds:mfc90u_600   ; CSimpleStringT.text:10260EAE                 mov     [ebp+var_4], 0FFFFFFFFh.text:10260EB5                 lea     ecx, [ebp+var_90].text:10260EBB                 call    sub_1026BA80.text:10260EC0                 mov     eax, [ebp+var_B8].text:10260EC6                 jmp     loc_1026103B

And this is exactly where the memory was corrupted:

ntdll!RtlpLowFragHeapFree:77352d0b 8bff            mov     edi,edi77352d0d 55              push    ebp77352d0e 8bec            mov     ebp,esp77352d10 83ec28          sub     esp,28h77352d13 53              push    ebx77352d14 56              push    esi77352d15 57              push    edi77352d16 8d7af8          lea     edi,[edx-8]77352d19 807f0705        cmp     byte ptr [edi+7],577352d1d 0f848cf20300    je      ntdll!RtlpLowFragHeapFree+0x14 (77391faf)77352d23 8b07            mov     eax,dword ptr [edi]77352d25 8bf7            mov     esi,edi77352d27 c1ee03          shr     esi,377352d2a 33f0            xor     esi,eax77352d2c 3335dc713d77    xor     esi,dword ptr [ntdll!RtlpLFHKey (773d71dc)] <-- taint77352d32 897dfc          mov     dword ptr [ebp-4],edi77352d35 33f1            xor     esi,ecx77352d37 8b4604          mov     eax,dword ptr [esi+4]77352d3a 8945f4          mov     dword ptr [ebp-0Ch],eax77352d3d c6470780        mov     byte ptr [edi+7],80h77352d41 c6470600        mov     byte ptr [edi+6],077352d45 8b5e08          mov     ebx,dword ptr [esi+8] <-- taint77352d48 8b4e0c          mov     ecx,dword ptr [esi+0Ch]77352d4b 895de0          mov     dword ptr [ebp-20h],ebx <-- taint77352d4e 83c301          add     ebx,177352d51 894de4          mov     dword ptr [ebp-1Ch],ecx77352d54 83d101          adc     ecx,177352d57 81e3ff7f0000    and     ebx,7FFFh77352d5d 663b5e14        cmp     bx,word ptr [esi+14h]77352d61 0f84296c0000    je      ntdll!RtlpLowFragHeapFree+0x62 (77359990)77352d67 8b45e0          mov     eax,dword ptr [ebp-20h] <-- taint77352d6a 8b55e4          mov     edx,dword ptr [ebp-1Ch]77352d6d 0facd010        shrd    eax,edx,10h
!!:77352d71 66894708        mov     word ptr [edi+8],ax <-- put an arbitrary word into our CException vftable

This is the freshly overwritten pointer to CException object which will be later used:

0:000> db edi+80a2232a8  62 00 11 5f 01 00 00 00-03 00 00 00 70 df 36 5f  b.._........p.6_0a2232b8  fe 95 50 14 61 00 00 80-65 00 6d 00 65 00 74 00  ..P.a...e.m.e.t.0a2232c8  65 00 72 00 73 00 0d 00-f3 95 50 14 5b 00 00 80  e.r.s.....P.[...0a2232d8  68 00 3e 00 7c 00 31 00-7c 00 30 00 7c 00 30 00  h.>.|.1.|.0.|.0.0a2232e8  f4 95 50 14 7c 00 00 80-6b 00 30 00 2e 00 30 00  ..P.|...k.0...0.0a2232f8  30 00 30 00 30 00 30 00-c9 95 50 14 30 00 00 80  0.0.0.0...P.0...0a223308  6e 00 30 00 30 00 30 00-30 00 30 00 7c 00 30 00  n.0.0.0.0.0.|.0.0a223318  ca 95 50 14 30 00 00 80-71 00 30 00 30 00 7c 00  ..P.0...q.0.0.|.

So, in theory we can control at least 2 least significant bytes of the pointer to CException object:
0a2232a8  62 00 11 5f 

Then, if we craft a CException object at this address, the second pointer of the object's vftable will be called upon trigger.

