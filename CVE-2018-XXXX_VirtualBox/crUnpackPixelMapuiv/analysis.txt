Arbitrary pointer dereference in Oracle VirtualBox “crUnpackPixelMapuiv”

Testing: VirtualBox v5.2.12 x64 
VM: Windows 7 x64
Host OS: Windows 10 x64, April 2018


VirtualBox’s Chromium host-side code blindly trusts the pointer provided by the VM while handling the CR_GETPIXELMAPUIV_EXTEND_OPCODE. The bug is in crUnpackPixelMapuiv (/VirtualBox-5.2.12/src/VBox/HostServices/SharedOpenGL/unpacker/unpack_pixelmap.c):

void crUnpackPixelMapuiv( void  )
{
    GLenum map = READ_DATA( sizeof( int ) + 0, GLenum );
    GLsizei mapsize = READ_DATA( sizeof( int ) + 4, GLsizei );
    int nodata = READ_DATA( sizeof(int) + 8, int);
    GLuint *values;

    if (nodata)
        values = (GLuint*) (uintptr_t) READ_DATA(sizeof(int) + 12, GLint);
    else
        values = DATA_POINTER( sizeof( int ) + 16, GLuint ); // —————> (1)
        
    cr_unpackDispatch.PixelMapuiv( map, mapsize, values ); // —————> (0)
    INCR_VAR_PTR();
}

In the prologue, it reads data values (via READ_DATA) directly from the Chromium SPU sent by the VM, which is fully controlled by the attacker. In case that the `nodata` variable read from the SPU is true, then it also reads a data pointer (via DATA_POINTER) into the `values` variable (line (1)). This pointer is then passed as the 3rd argument to OpenGL’s PixelMapuiv, where it is dereferenced for a certain memory operation. For example, if we set `values` to 0xF1414141, then an read a/v is observed at address 0xfffffffff1414141.

Note: because PixelMapuiv is provided by the host environment, it may behave differently in a different host OS. 

See also: 
VBox.log - crash log from VirtualBox VM 
crash.png - screenshot of the crash