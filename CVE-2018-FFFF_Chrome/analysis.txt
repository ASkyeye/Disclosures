Chromium ANGLE uninitialized variable vulnerability

VULNERABILITY DETAILS

Blit11::copyAndConvert(/src/libANGLE/renderer/d3d/d3d11/Blit11.cpp) does not check the return value of ID3D11DeviceContext::Map, when it's called on a system which has Nvidia drivers below a certain version installed:

1515: gl::Error Blit11::copyAndConvert
...
1530:{
1531:    ANGLE_TRY(initResources());
1532:
1533:    ID3D11DeviceContext *deviceContext = mRenderer->getDeviceContext();
...
1550:    // Work around timeouts/TDRs in older NVIDIA drivers.
1551:    if (mRenderer->getWorkarounds().depthStencilBlitExtraCopy)
1552:    {
1553:        D3D11_MAPPED_SUBRESOURCE mapped;
1554:        deviceContext->Map(destStaging.get(), 0, D3D11_MAP_READ, 0, &mapped);
1555:        deviceContext->UpdateSubresource(dest.get(), destSubresource, nullptr, mapped.pData,
1556:                                         mapped.RowPitch, mapped.DepthPitch);
1557:        deviceContext->Unmap(destStaging.get(), 0);
1558:    }
...
1565:    return gl::NoError();
1566:}

On line 1554, ID3D11DeviceContext::Map is called, and the call is expected to assign a value to the `mapped` local variable. However, Map can fail in certain circumstances, as per the documentation (https://msdn.microsoft.com/en-us/library/windows/desktop/ff476457(v=vs.85).aspx). In practice it is known to fail on the OOM condition (https://community.amd.com/thread/128535), which may be specifically induced by the attacker. In case that the Map call fails, then ID3D11DeviceContext::UpdateSubresource will be called (line 1555), that will copy whatever data is pointed to by the random content of the uninitialized variable `mapped` to the output buffer provided by the caller. 

Reachability analysis:

There are multiple code paths which result in calling the vulnerable function. Consider the following call chain, for example:

(JavaScript WebGL2 context) ->
Context::blitFramebuffer -> 
Framebuffer::blit -> 
FramebufferD3D::blit -> 
Framebuffer11::blitImpl -> 
Renderer11::blitRenderbufferRect -> 
Blit11::copyStencil -> 
Blit11::copyDepthStencilImpl -> 
Blit11::copyAndConvert.

The vulnerable function Blit11::copyAndConvert is reachable via the blitFramebuffer Javascript function of the WebGL2 context. In case that the vulnerability is triggered, ID3D11DeviceContext::UpdateSubresource will copy data from a random pointer (as it's provided by the random contents of the uninitialized variable `mapped`) to the destination rectangle provided in the arguments to blitFramebuffer. The pixels of the displayed rectangle can then be read back by the attacker via canvas.getImageData (https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData), thereby resulting in memory disclosure.

Exploitation:

1. groom the stack in order to cause a meaningful memory pointer appearing in the `mapped` variable, while it's still uninitialized (via leftowers from previous stack operations)
2. cause an OOM, or otherwise induce a fallible condition to ID3D11DeviceContext::UpdateSubresource 
3. call WebGL2's blitFramebuffer (within an initialized WebGL2 context, etc.)
4. draw the leaked buffer on the screen 
5. read the drawn pixels back via canvas.getImageData, which represent memory bytes
6. use the obtained memory data (which may contain pointers to executable modules or some sensitive data) to bypass ASLR, or to read user's passwords, for example.


VERSION
The issue was verified in the latest trunk code of ANGLE.


REPRODUCTION CASE
I don't have a repro, since it requires very specific conditions to trigger. Specifically, the vulnerable path of the code will be triggered, if the system has Nvidia drivers, and the drivers version is below 13.6881, as per GenerateWorkarounds() (/src/libANGLE/renderer/d3d/d3d11/renderer11_utils.cpp).