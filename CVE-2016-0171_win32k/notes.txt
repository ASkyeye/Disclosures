KB Windows 7 x86:
July 3618965
May (original) 3153199 3156017

	CVE-2016-0171 vulnerability analysis

Triggers on Windows 7 x32, only with Special pool enabled. The PoC is only available for x32, but it should be possible to port for x64.
Basically it�s a use after free, the freed pointer looks like a handle to a Bitmap.
The crash occures inside a destructor that apparently was provided with a buffer with an already freed pointer inside.
Overall the bug looks interesting. The only obstruction to exploitation can be that the free/re-use window is too small, but I don�t see that�s the case.

win32k!DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ:
983e5f8c 8bff            mov     edi,edi
983e5f8e 55              push    ebp
983e5f8f 8bec            mov     ebp,esp
983e5f91 51              push    ecx
983e5f92 51              push    ecx
983e5f93 56              push    esi
983e5f94 57              push    edi
983e5f95 8bf1            mov     esi,ecx <� freed pointer inside already?
983e5f97 bf00100000      mov     edi,1000h
983e5f9c 857e24          test    dword ptr [esi+24h],edi
983e5f9f 740c            je      win32k!DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ+0x21 (983e5fad)
983e5fa1 e81b460000      call    win32k!DEVLOCKBLTOBJ::vUnMap (983ea5c1)
983e5fa6 8bce            mov     ecx,esi
983e5fa8 e8db450000      call    win32k!DEVLOCKBLTOBJ::vFlushSpriteUpdates (983ea588)
983e5fad 53              push    ebx
983e5fae 8d4614          lea     eax,[esi+14h]
983e5fb1 33db            xor     ebx,ebx
983e5fb3 8945fc          mov     dword ptr [ebp-4],eax <� stored address of the crashing ptr
983e5fb6 3918            cmp     dword ptr [eax],ebx
983e5fb8 743d            je      win32k!DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ+0x6b (983e5ff7)
983e5fba 8b4620          mov     eax,dword ptr [esi+20h]
983e5fbd 3918            cmp     dword ptr [eax],ebx
983e5fbf 7412            je      win32k!DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ+0x47 (983e5fd3)
983e5fc1 8b4e1c          mov     ecx,dword ptr [esi+1Ch]
983e5fc4 8b00            mov     eax,dword ptr [eax]
983e5fc6 53              push    ebx
983e5fc7 6a01            push    1
983e5fc9 ff7114          push    dword ptr [ecx+14h] <� crash here due to freed mem access
983e5fcc ff30            push    dword ptr [eax]
983e5fce e8ea7dffff      call    win32k!hbmSelectBitmap (983dddbd) <� looks like it�s a freed bitmap handle
983e5fd3 8b45fc          mov     eax,dword ptr [ebp-4] 
983e5fd6 8b00            mov     eax,dword ptr [eax]
983e5fd8 3bc3            cmp     eax,ebx
983e5fda 7406            je      win32k!DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ+0x56 (983e5fe2)
983e5fdc 50              push    eax
983e5fdd e81af3feff      call    win32k!DEC_SHARE_REF_CNT (983d52fc)
983e5fe2 8b45fc          mov     eax,dword ptr [ebp-4] 
983e5fe5 8b00            mov     eax,dword ptr [eax]
983e5fe7 ff7014          push    dword ptr [eax+14h] <� use
983e5fea e84713feff      call    win32k!bDeleteSurface (983c7336)
983e5fef 8b45fc          mov     eax,dword ptr [ebp-4]
983e5ff2 8918            mov     dword ptr [eax],ebx
983e5ff4 895e20          mov     dword ptr [esi+20h],ebx
983e5ff7 8b4624          mov     eax,dword ptr [esi+24h]
983e5ffa 85c7            test    edi,eax
983e5ffc 7452            je      win32k!DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ+0xc4 (983e6050)
983e5ffe 8bce            mov     ecx,esi
983e6000 a900800000      test    eax,8000h

kd> kb
  *** Stack trace for last set context - .thread/.cxr resets it
 # ChildEBP RetAddr  Args to Child              
00 aba3fafc 983e7b6d 592106c9 983c4dcb 002bfda4 win32k!DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ+0x3d
01 aba3fbcc 983c4dfa 592106c9 00000062 00000055 win32k!NtGdiBitBltInternal+0x73b
02 aba3fc00 8184ea06 592106c9 00000062 00000055 win32k!NtGdiBitBlt+0x2f
03 aba3fc00 771971b4 592106c9 00000062 00000055 nt!KiSystemServicePostCall
04 002bfd6c 75507349 75507331 592106c9 00000062 ntdll!KiFastSystemCallRet
05 002bfd70 75507331 592106c9 00000062 00000055 GDI32!NtGdiBitBlt+0xc
06 002bfdb4 00f81399 00420eb8 00000062 00000055 GDI32!BitBlt+0x1fa
WARNING: Stack unwind information not available. Following frames may be wrong.
07 002bfdf0 00f815e3 00000001 004003e8 00400420 poc_p3_04+0x1399
08 002bfe3c 7730ee6c 7ffdf000 002bfe88 771b3ab3 poc_p3_04+0x15e3
09 002bfe48 771b3ab3 7ffdf000 770cd107 00000000 kernel32!BaseThreadInitThunk+0xe
0a 002bfe88 771b3a86 00f81660 7ffdf000 00000000 ntdll!__RtlUserThreadStart+0x70
0b 002bfea0 00000000 00f81660 7ffdf000 00000000 ntdll!_RtlUserThreadStart+0x1b

	The PoC code

Basically the PoC code works as follows:
1. Create some HDCs
2. Create a bitmap
3. Delete a bitmap
4. Call BitBlt() to copy the deleted bitmap from hdc to another hdc.

	Root Cause

Within win32k!NtGdiBitBltInternal(), there is a local variable which is first filled with pointers to graphical objects in operation:

.text:BF8D7C8D loc_BF8D7C8D:                           ; CODE XREF: NtGdiBitBltInternal(x,x,x,x,x,x,x,x,x,x,x)+1C0j
.text:BF8D7C8D                 lea     ecx, [ebp+pointers_array]
.text:BF8D7C93                 call    ??0DEVLOCKBLTOBJ@@QAE@XZ ; DEVLOCKBLTOBJ::DEVLOCKBLTOBJ(void)
.text:BF8D7C98                 push    0
.text:BF8D7C9A                 lea     eax, [ebp+var_2C]
.text:BF8D7C9D                 push    eax
.text:BF8D7C9E                 lea     eax, [ebp+var_20]
.text:BF8D7CA1                 push    eax
.text:BF8D7CA2                 lea     ecx, [ebp+pointers_array]
.text:BF8D7CA8                 call    ?bLock@DEVLOCKBLTOBJ@@QAEHAAVXDCOBJ@@0H@Z ; DEVLOCKBLTOBJ::bLock(XDCOBJ &,XDCOBJ &,int)

In some conditions, this array is passed to DEVLOCKBLTOBJ destructor, in which the crash happens:

.text:BF8D81EF jmp_crash:                              ; CODE XREF: NtGdiBitBltInternal(x,x,x,x,x,x,x,x,x,x,x)+2EBj
.text:BF8D81EF                                         ; NtGdiBitBltInternal(x,x,x,x,x,x,x,x,x,x,x)+70Ej ...
.text:BF8D81EF                 lea     ecx, [ebp+pointers_array] ; culprit ptr array
.text:BF8D81F5                 call    ??1DEVLOCKBLTOBJ@@QAE@XZ ; DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ(void)
.text:BF8D81FA                 jmp     short loc_BF8D8227

The crash occures because the code tries to dereference a dangling pointer, i.e. the pointer to the previously freed bitmap.

Why it happens? Compare unpatched vs. patched code at DEVLOCKBLTOBJ::~DEVLOCKBLTOBJ:

.text:BF8D663B                 mov     ecx, [esi+20h]  ; source hdc
.text:BF8D663E                 mov     eax, [eax]
.text:BF8D6640                 push    ebx
.text:BF8D6641                 push    1
.text:BF8D6643                 push    dword ptr [ecx+14h] ; crash 0171
.text:BF8D6646                 push    dword ptr [eax]
.text:BF8D6648                 call    _hbmSelectBitmap@16 ; hbmSelectBitmap(x,x,x,x)

patched:
.text:BF8D6703                 mov     eax, [eax]
.text:BF8D6705                 push    ebx
.text:BF8D6706                 push    1
.text:BF8D6708                 push    dword ptr [esi+20h] ; a different pointer/offset
.text:BF8D670B                 push    dword ptr [eax]
.text:BF8D670D                 call    _hbmSelectBitmap@16 ; hbmSelectBitmap(x,x,x,x)

The patch affects pointer dereference order, i.e. a double dereference is patched to a single dereference, as in *(*(ptr+0x20)+0x14) vs. *(ptr+0x20). Same change was applied to DEVLOCKBLTOBJ::vUnmap (called from within the destructor).

But the main patch is in DEVLOCKBLTOBJ::bLock() that is called from the DEVLOCKBLTOBJ constructor, which presumably is the culprit of populating the operational array with dangling pointers. Most relevant changed block:

unpatched:
.text:BF8D78DF                 mov     eax, [ebp+arg_4]
.text:BF8D78E2                 mov     [esi+24h], eax
.text:BF8D78E5                 mov     eax, [eax]
.text:BF8D78E7                 mov     eax, [eax+1F8h]
.text:BF8D78ED                 mov     [esi+20h], eax
.text:BF8D78F0                 add     eax, 10h
.text:BF8D78F3                 push    eax
.text:BF8D78F4                 lea     edi, [esi+14h]
.text:BF8D78F7                 push    edi
.text:BF8D78F8                 call    ?bCopySurface@@YGHPAVSURFMEM@@PAU_SURFOBJ@@@Z ; bCopySurface(SURFMEM *,_SURFOBJ *)
.text:BF8D78FD                 test    eax, eax
.text:BF8D78FF                 jnz     short loc_BF8D792A

patched:
.text:BF8D79B9                 mov     [esi+24h], ebx
.text:BF8D79BC                 mov     eax, [ebx]
.text:BF8D79BE                 mov     eax, [eax+1F8h]
.text:BF8D79C4                 mov     eax, [eax+14h]
.text:BF8D79C7                 mov     [esi+20h], eax
.text:BF8D79CA                 mov     eax, [ebx]
.text:BF8D79CC                 mov     eax, [eax+1F8h]
.text:BF8D79D2                 add     eax, 10h
.text:BF8D79D5                 push    eax
.text:BF8D79D6                 lea     edi, [esi+14h]
.text:BF8D79D9                 push    edi
.text:BF8D79DA                 call    ?bCopySurface@@YGHPAVSURFMEM@@PAU_SURFOBJ@@@Z ; bCopySurface(SURFMEM *,_SURFOBJ *)
.text:BF8D79DF                 test    eax, eax
.text:BF8D79E1                 jnz     short loc_BF8D7A0C

The patched code changes the way how the DEVLOCKBLTOBJ operational array of pointers is populated, apparently leaving the dangling pointer away.

	Notes

BitBlt function
The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.

BOOL BitBlt(
  _In_ HDC   hdcDest,
  _In_ int   nXDest,
  _In_ int   nYDest,
  _In_ int   nWidth,
  _In_ int   nHeight,
  _In_ HDC   hdcSrc,
  _In_ int   nXSrc,
  _In_ int   nYSrc,
  _In_ DWORD dwRop
);

https://msdn.microsoft.com/ru-ru/library/windows/desktop/dd183370(v=vs.85).aspx



SelectObject function
The SelectObject function selects an object into the specified device context (DC). The new object replaces the previous object of the same type.
HGDIOBJ SelectObject(
  _In_ HDC     hdc,
  _In_ HGDIOBJ hgdiobj
);

https://msdn.microsoft.com/en-us/library/windows/desktop/dd162957(v=vs.85).aspx