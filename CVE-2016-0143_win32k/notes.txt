-?- Is it possible to trigger the bug via a different path to get better exploitation conditions?

If we look at the vulnerable xxxRealDrawMenuItem() call chain, it starts forking backwards at the call to xxxDrawMenuItem(), that may be called from:
* xxxHotTrackMenu() 
^-- this goes up to tracking mouse moves, processing of system messages (xxxScanSysQUeue()), and finally lands at the exported function NtUserRealInternalGetMessage(); another path sets at NtUserSetFocus(); there are possibly other Nt* landings 
* xxxMNInvertItem() 
^-- this goes up through menu items manipulation, key tracking, and lands at xxxWrapRealDefWindowProc()
* xxxMenuDraw() <-- this is the original poc's path


-?- Understand the situation of debugger code altering the stack. In what exactly conditions is the stack altered? What is the written value and why? How can I manipulate the value written on the stack?

What we know at this point:
1. Before the vulnerable function, xxxRealDrawMenuItem(), is called from xxxDrawState():
GreSetLayout() is called a few times, with HmgLockEx() call inside, which sets the vulnerable stack slot to HmgLockEx() return address.
2. In case that a kernel bp was set on xxxRealDrawMenuItem() (possibly in other cases as well):
nt!KiDebugTrapOrFault() is called before executing the xxxRealDrawMenuItem(), that calls KxContextToKFrames(), that nulls the vulnerable stack slot (or possibly writes another value to it).
3. Finally, xxxRealDrawMenuItem() is called and goes to crash (or possibly loops in KiDebugTrapOrFault() in some cases).

So basically, when a bp is put on a function, upon entrance into that function, nt!KiDebugTrapOrFault() is called.
Because of this it is possible to generate a recursion on kernel stack by putting a bp on a debugger's function (eg. nt!KxContextToKeFrames()). 

Let's ba w on the vulnerable stack slot to see who and when alters it.
Vulnerable stack slot relative to xxxDrawMenuItem's return address:

0: kd> k
 # Child-SP          RetAddr           Call Site
00 fffff880`15b905f8 fffff960`0023c55b win32k!xxxRealDrawMenuItem
01 fffff880`15b90600 fffff960`001f6dd6 win32k!xxxDrawState+0x5e7
02 fffff880`15b90770 fffff960`001f847e win32k!xxxDrawMenuItem+0x516
03 fffff880`15b90830 fffff960`001f8db6 win32k!xxxMenuDraw+0x346
04 fffff880`15b90900 fffff960`001a55cb win32k!xxxDrawMenuBarTemp+0x2aa
05 fffff880`15b909e0 fffff800`016d4613 win32k!NtUserDrawMenuBarTemp+0xe7
06 fffff880`15b90a70 00000000`776bae6a nt!KiSystemServiceCopyEnd+0x13
07 00000000`001bfdf8 00000000`777007c7 0x776bae6a
08 00000000`001bfe00 00000000`00010193 0x777007c7
09 00000000`001bfe08 00000000`00000000 0x10193

0: kd> dqs fffff880`15b90770-278 l1
fffff880`15b904f8  00000000`00000000

Crashing offsets:
fffff880`1484b460 fffff960`0020c55b : 00000000`07010725 00000000`00000000 00000000`00000000 fffff960`00157771 : win32k!xxxRealDrawMenuItem+0x6ea
fffff880`1484b600 fffff960`001c6dd6 : 00000000`00000001 00000000`0110007c fffff880`1484b7d0 fffff900`c0815e80 : win32k!xxxDrawState+0x5e7

Got a loop:

1: kd> g
Breakpoint 1 hit
nt!KiDebugTrapOrFault+0xb7:
fffff800`016c62b7 0f295510        movaps  xmmword ptr [rbp+10h],xmm2
1: kd> g
Single step exception - code 80000004 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
win32k!xxxDrawState+0x5da:
fffff960`0022c54e c744242001000000 mov     dword ptr [rsp+20h],1
1: kd> g
Breakpoint 1 hit
nt!KxContextToKframes+0x1ce:
fffff800`016f148e 488b83c0010000  mov     rax,qword ptr [rbx+1C0h]
1: kd> g
Breakpoint 1 hit
nt!KiDebugTrapOrFault+0xb7:
fffff800`016c62b7 0f295510        movaps  xmmword ptr [rbp+10h],xmm2
1: kd> k
 # Child-SP          RetAddr           Call Site
00 fffff880`15bae470 fffff960`0022c54e nt!KiDebugTrapOrFault+0xb7
01 fffff880`15bae600 fffff960`001e6dd6 win32k!xxxDrawState+0x5da
02 fffff880`15bae770 fffff960`001e847e win32k!xxxDrawMenuItem+0x516
03 fffff880`15bae830 fffff960`001e8db6 win32k!xxxMenuDraw+0x346
04 fffff880`15bae900 fffff960`001955cb win32k!xxxDrawMenuBarTemp+0x2aa
05 fffff880`15bae9e0 fffff800`016c8613 win32k!NtUserDrawMenuBarTemp+0xe7
06 fffff880`15baea70 00000000`76e2ae6a nt!KiSystemServiceCopyEnd+0x13
07 00000000`0020fa18 00000000`76e707c7 user32!NtUserDrawMenuBarTemp+0xa
08 00000000`0020fa20 00000001`3fa8144a user32!DrawMenuBarTemp+0x5f
09 00000000`0020fa60 00000001`3fa9d2fc 0x00000001`3fa8144a
0a 00000000`0020fa68 00000000`00000000 0x00000001`3fa9d2fc
1: kd> bl
 0 d fffff960`0022bf74 e 1 0001 (0001) win32k!xxxDrawState
 1 e fffff880`15bae4f8 w 1 0001 (0001) 
 2 e fffff960`0022c54e e 1 0001 (0001) win32k!xxxDrawState+0x5da

Latest result: I can monitor all writes to the vulnerable stack slot; there is a lot of them, both from HmgLockEx() surrounding internals and debugger internals. The slot is nulled if I put bp before entrance to xxxRealDrawMenuItem(), not nulled if only bp on memory. 


-?- Can I manipulate the write address (uninitialized variable) and how? 
-?- Is it possible to put arbitrary value into the uninitialized variable via program's logic, eg. by manipulating the PoC values?

No:
1. The culprit uninitialized variable is (by design) expected to hold a pointer.
2. The only way to initialize the variable via program's logic is inside GreCreateDIBitmapReal() function.
3. Inside the GreCreateDIBitmapReal(), the variable *can possibly* be initialized via following logic:
GreCreateDIBitmapReal() -> SURFMEM::bCreateDIB() -> AllocateObject(), which puts the pointer into the culprit variable.
4. The code of AllocateObject() basically tries to allocate memory in three ways:
ExAllocateFromPagedLookasideList(x), PALLOCMEM(), Win32AllocPool(), 
ie. either from the Lookaside List or directly from the pool,
and it will return either a valid pointer or NULL if it failed to allocate.
5. Hence in theory, we could only manipulate the logic to get a valid free memory pointer, which is equivalent to normal program execution and hence would render the bug useless. 

Thus, the bug in theory is not exploitable, because the buggy pointer can only reference historical data on the stack:
1. NULL
This was possible to exploit only on earlier versions of Windows by allocating the NULL page in kernel, but it's not possible to CVE date.
2. HmgLockEx() address (persistent on Windows 7 x64).


-?- What exactly does the PoC do?


-?- What is the Windows procedure for kernel bugs handling / bugcheck?

Really basics: http://www.osronline.com/article.cfm?article=82
More basics: http://social.technet.microsoft.com/wiki/contents/articles/6302.windows-bugcheck-analysis.aspx


-?- What do BSOD numbers mean?

Reference: https://msdn.microsoft.com/en-us/library/windows/hardware/hh994433(v=vs.85).aspx
bugcodes.h
!analyze -show Code

Favorites:
FAT_FILE_SYSTEM
FLOPPY_INTERNAL_ERROR
IMPERSONATING_WORKER_THREAD
INSTALL_MORE_MEMORY


-?- What is the bug's root cause? The pattern? Similar bug vectors ideas?

Indeed the root cause is uninitialized stack variable in xxxRealDrawMenuItem(): in the vulnerable code, it's passed to GreCreateDIBitmapReal() without being initialized, while in the patched code it's nulled prior to any use:

.text:BF907601                 mov     [ebp+var_1C], edi
.text:BF907604                 call    _GreCreateCompatibleDC@4 ; GreCreateCompatibleDC(x)
.text:BF907609                 mov     [ebp+arg_C], eax
.text:BF90760C                 cmp     eax, edi
.text:BF90760E                 jz      loc_BF907731
.text:BF907614                 push    2Ch             ; size_t
.text:BF907616                 lea     eax, [ebp+var_68]
.text:BF907619                 push    edi             ; int
.text:BF90761A                 push    eax             ; void *
.text:BF90761B                 call    _memset
.text:BF907620                 mov     eax, [ebp+arg_8]
.text:BF907623                 add     esp, 0Ch
.text:BF907626                 push    20h
.text:BF907628                 mov     [ebp+var_64], eax
.text:BF90762B                 xor     eax, eax
.text:BF90762D                 inc     eax
.text:BF90762E                 mov     [ebp+var_5C], ax
.text:BF907632                 pop     eax
.text:BF907633                 mov     [ebp+var_5A], ax
.text:BF907637                 lea     eax, [ebp+var_1C]
.text:BF90763A                 push    eax             ; int
.text:BF90763B                 push    edi             ; int
.text:BF90763C                 push    edi             ; char
.text:BF90763D                 push    edi             ; int
.text:BF90763E                 push    edi             ; int
.text:BF90763F                 push    edi             ; int
.text:BF907640                 push    edi             ; int
.text:BF907641                 push    2Ch             ; int
.text:BF907643                 push    edi             ; int
.text:BF907644                 lea     eax, [ebp+var_68]
.text:BF907647                 push    eax             ; int
.text:BF907648                 push    edi             ; Section
.text:BF907649                 push    edi             ; int
.text:BF90764A                 push    [ebp+arg_C]     ; int
.text:BF90764D                 mov     [ebp+var_68], 28h
.text:BF907654                 mov     [ebp+var_60], ebx
.text:BF907657                 mov     [ebp+var_58], edi
.text:BF90765A                 call    _GreCreateDIBitmapReal@52 ; GreCreateDIBitmapReal(x,x,x,x,x,x,x,x,x,x,x,x,x)

The pattern: a read reference to a function's stack variable comes prior to the write reference, in the function's call graph linear time. Not very useful as a bug hunting vector, bc manipulating the stack will not be stable exploitation wise. 


-?- Why exactly is the variable not initialized, in terms of the PoC? How should it be initialized normally? 
 
While the bug's root cause is the lack of a local variable initialization within the xxxRealDrawMenuItem() function, the de-facto culprit is GreCreateDIBitmapReal() function, which is the first entity to operate on the uninitialized variable. From the code graph we can see that GreCreateDIBitmapReal() function sets the variable in most cases, otherwise it returns NULL. In most cases when it returns NULL, it will also set the error code to 0x57, that is ERROR_INVALID_PARAMETER. 

Therefore, the bug is observed due to a combination of two programming errors, both of which were patched. 
In terms of bug triggering, it is required that xxxRealDrawMenuItem() would pass an invalid parameter to GreCreateDIBitmapReal().

Windows error codes: https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms681382(v=vs.85).aspx


-?- Why do KD internals null the stack? How do they work?


-?- Why does the bp get looped and in what exactly conditions? 


-?- Who calls HmgLockEx()?

xxxDrawMenuItem() -> xxxDrawState() -> GreSetLayout() -> DCOBJ::DCOBJ() -> XDCOBJ::vLock() -> HmgLockEx() -> HANDLELOCK::~HANDLELOCK()
...-> xxxRealDrawMenuItem()
There is a set of Hmg* functions in the kernel, and they seem to be responsible for Handle ManaGement.
HmgLockEx either locks or unlocks the given handle, according the the arguments.
HmgLockEx+122 is the return address from HANDLELOCK::~HANDLELOCK destructor near end of the x64 HmgLockEx() procedure, which is by the way very different from the x32 version of the same function.

0: kd> ba e1 hmglockex+122
0: kd> g
Breakpoint 2 hit
win32k!HmgLockEx+0x122:
fffff960`001179a2 4c8d5c2450      lea     r11,[rsp+50h]
0: kd> k
 # Child-SP          RetAddr           Call Site
00 fffff880`13576520 fffff960`00118fce win32k!HmgLockEx+0x122
01 fffff880`13576590 fffff960`0023bc56 win32k!XDCOBJ::vLock+0x1e
02 fffff880`135765c0 fffff960`001cc4fc win32k!GreSetLayout+0x2a
03 fffff880`13576600 fffff960`00186dd6 win32k!xxxDrawState+0x588
04 fffff880`13576770 fffff960`0018847e win32k!xxxDrawMenuItem+0x516
05 fffff880`13576830 fffff960`00188db6 win32k!xxxMenuDraw+0x346
06 fffff880`13576900 fffff960`001355cb win32k!xxxDrawMenuBarTemp+0x2aa
07 fffff880`135769e0 fffff800`016bc613 win32k!NtUserDrawMenuBarTemp+0xe7
08 fffff880`13576a70 00000000`772fae6a nt!KiSystemServiceCopyEnd+0x13
09 00000000`0019f6f8 00000000`773407c7 0x772fae6a
0a 00000000`0019f700 00000000`00010197 0x773407c7
0b 00000000`0019f708 00000000`00000000 0x10197


-?- Who nulls the HmgLockEx return address on the stack? Or is it not called?

The HmgLockEx() function is definitely called every time, including the null crase case, as we can see by setting a bp on GreSetLayout() and bp HmgLockEx from there. 
In some cases a random number will appear in the culprit memory slot, causing a different crash:

win32k!xxxRealDrawMenuItem+0x6b0:
fffff960`0018755c 410fb64801      movzx   ecx,byte ptr [r8+1] ds:002b:00000000`00000019=??

0: kd> dqs fffff880`135764f8 l1
fffff880`135764f8  00000000`00000018

Hence someone is corrupting the stack to cause a null crash. 

Let's calculate the exact location of the culprit stack slot:
fffff880`135715f8 - ret address of xxxDrawState

0: kd> ? fffff880`135715f8-fffff880`135714f8
Evaluate expression: 256 = 00000000`00000100
0: kd> dqs fffff880`135715f8-100 l1
fffff880`135714f8  fffff960`001279a2 win32k!HmgLockEx+0x122


It's nt!KxContextToKframes(), related to debugging:

Breakpoint 2 hit
nt!KxContextToKframes+0x1ea:
fffff800`016b44aa 488b83d0010000  mov     rax,qword ptr [rbx+1D0h]
1: kd> k
 # Child-SP          RetAddr           Call Site
00 fffff880`133beac0 fffff800`0168c533 nt!KxContextToKframes+0x1ea
01 fffff880`133beb00 fffff800`016c7a51 nt!KeContextToKframes+0x83
02 fffff880`133bebe0 fffff800`0168ba02 nt!KiDispatchException+0x155
03 fffff880`133bf280 fffff800`016893a2 nt!KiExceptionDispatch+0xc2
04 fffff880`133bf460 fffff960`001b6eac nt!KiDebugTrapOrFault+0x1a2
05 fffff880`133bf5f8 fffff960`001fc55b win32k!xxxRealDrawMenuItem
06 fffff880`133bf600 fffff960`001b6dd6 win32k!xxxDrawState+0x5e7
07 fffff880`133bf770 fffff960`001b847e win32k!xxxDrawMenuItem+0x516
08 fffff880`133bf830 fffff960`001b8db6 win32k!xxxMenuDraw+0x346
09 fffff880`133bf900 fffff960`001655cb win32k!xxxDrawMenuBarTemp+0x2aa
0a fffff880`133bf9e0 fffff800`0168b613 win32k!NtUserDrawMenuBarTemp+0xe7
0b fffff880`133bfa70 00000000`76d1ae6a nt!KiSystemServiceCopyEnd+0x13
0c 00000000`0012f778 00000000`76d607c7 user32!NtUserDrawMenuBarTemp+0xa
0d 00000000`0012f780 00000001`3fca144a user32!DrawMenuBarTemp+0x5f
0e 00000000`0012f7c0 00000001`3fcbd2fc 0x00000001`3fca144a
0f 00000000`0012f7c8 00000000`00000000 0x00000001`3fcbd2fc
1: kd> dqs fffff880`133bf4f8 l1
fffff880`133bf4f8  00000000`00000000
1: kd> ? rax
Evaluate expression: 0 = 00000000`00000000

Next the null-crash occurs, and the stack slot is never touched again.

From the WRK:

  237 PXMM_SAVE_AREA32
  238 KxContextToKframes (
  239     __inout PKTRAP_FRAME TrapFrame,
  240     __inout PKEXCEPTION_FRAME ExceptionFrame,
  241     __in PCONTEXT ContextRecord,
  242     __in ULONG ContextFlags,
  243     __in KPROCESSOR_MODE PreviousMode
  244     )
  245 
  246 /*++
  247 
  248 Routine Description:
  249 
  250     This routine moves the selected contents of the specified context frame
  251     into the specified trap and exception frames according to the specified
  252     context flags.
  253 
  254 Arguments:
  255 
  256     TrapFrame - Supplies a pointer to a trap frame that receives the volatile
  257         context from the context record.
  258 
  259     ExceptionFrame - Supplies a pointer to an exception frame that receives
  260         the nonvolatile context from the context record.
  261 
  262     ContextRecord - Supplies a pointer to a context frame that contains the
  263         context that is to be copied into the trap and exception frames.
  264 
  265     ContextFlags - Supplies the set of flags that specify which parts of the
  266         context frame are to be copied into the trap and exception frames.
  267 
  268     PreviousMode - Supplies the processor mode for which the exception and
  269         trap frames are being built.
  270 
  271 Return Value:
  272 
  273     If the context operation is a set context and the legacy floating state is
  274     switched for the current thread, then the address of the legacy floating
  275     save area is returned as the function value. Otherwise, NULL is returned.
  276 
  277 --*/

http://gate.upm.ro/os/LABs/Windows_OS_Internals_Curriculum_Resource_Kit-ACADEMIC/WindowsResearchKernel-WRK/WRK-v1.2/base/ntos/ke/amd64/exceptn.c


+++++++++

KASLR fortune-telling.
1. Set a few kernel break-points according to your situation.
2. Reset the box to shuffle the symbols.
3. Read the telling. 
