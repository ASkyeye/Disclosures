CVE-2018-5144: Integer overflow during Unicode conversion

Overflow in nsUnicodeToBIG5::GetMaxLength can create memory-safety bugs in callers

nsUnicodeToBIG5::GetMaxLength (/ff-esr52/intl/uconv/ucvtw/nsUnicodeToBIG5.cpp) performs an unchecked integer computation based on the int32 value provided by the caller, and returns the result in the int32 out parameter provided by the caller:

NS_IMETHODIMP
nsUnicodeToBIG5::GetMaxLength(const char16_t* aSrc,
                              int32_t aSrcLength,
                              int32_t* aDestLength)
{
  *aDestLength = (aSrcLength * 2) + // <<<<<<<<<<<<<< (0)
                 (mPendingTrail ? 1 : 0) +
                 // If the lead ends up being paired, the bytes produced
                 // are already included above.
                 // If not, it produces a single '?'.
                 (mUtf16Lead ? 1 : 0);
  return NS_OK;
}

In case that aSrcLength is 0x7fffffff, or even 0x7ffffffd if the two flags mPendingTrail and mUtf16Lead are set to true, aDestLength will overflow at (0), and a near-zero negative value will be returned to the caller.

nsUnicodeToBIG5 is a member of nsIUnicodeEncoder family of classes, which provides an abstracted Unicode encoding facility to a variety of callers around the code base, including DOM and Javascript engines, which operate almost entirely on user-controlled data. The various nsUnicodeTo* classes may be invoked via a dispatcher instance of nsIUnicodeEncoder, as follows, for instance:

nsCOMPtr<nsIUnicodeEncoder> mEncoder;
mEncoder = EncodingUtils::EncoderForEncoding(charset); // charset value may be obtained from user-controlled data
mEncoder->GetMaxLength(src, src.Length(), ...);

In case that the charset is set to "big5", nsUnicodeToBIG5::GetMaxLength will be called. 

GetMaxLength is declared as follows in nsIUnicodeEncoder.h: 

  /**
   * Returns a quick estimation of the size of the buffer needed to hold the
   * converted data. Remember: this estimation is >= with the actual size of 
   * the buffer needed. It will be computed for the "worst case"
   *
   * @param aSrc        [IN] the source data buffer
   * @param aSrcLength  [IN] the length of source data buffer
   * @param aDestLength [OUT] the needed size of the destination buffer
   * @return            NS_OK_UENC_EXACTLENGTH if an exact length was computed
   *                    NS_ERROR_OUT_OF_MEMORY if OOM
   *                    NS_OK if all we have is an approximation
   */
  MOZ_MUST_USE NS_IMETHOD GetMaxLength(const char16_t* aSrc,
                                       int32_t aSrcLength,
                                       int32_t* aDestLength) = 0;
...

Note that because GetMaxLength is prototyped as fallible, the callers expect it to signal of any internal failure, and therefore are unlikely to double-check the validity of the returned value.

The implications of a buffer size estimation procedure returning a negative value are almost certainly security relevant, however the actual impact depends on how exactly the caller uses the returned value. Consider for example, nsScriptableUnicodeConverter::ConvertFromUnicodeWithLength (/ff-esr52/intl/uconv/nsScriptableUConv.cpp):

nsresult
nsScriptableUnicodeConverter::ConvertFromUnicodeWithLength(const nsAString& aSrc,
                                                           int32_t* aOutLen,
                                                           char **_retval)
{
  if (!mEncoder)
    return NS_ERROR_FAILURE;

  nsresult rv = NS_OK;
  int32_t inLength = aSrc.Length();
  const nsAFlatString& flatSrc = PromiseFlatString(aSrc);
  rv = mEncoder->GetMaxLength(flatSrc.get(), inLength, aOutLen); // <<< (1)
  if (NS_SUCCEEDED(rv)) {
    *_retval = (char*)malloc(*aOutLen+1); // <<<<<<<<<< (2)
    if (!*_retval)
      return NS_ERROR_OUT_OF_MEMORY;

    rv = mEncoder->Convert(flatSrc.get(), &inLength, *_retval, aOutLen); // <<<<<<<<<< (3)
    if (NS_SUCCEEDED(rv))
    {
      (*_retval)[*aOutLen] = '\0'; // <<<<<<<<<<< (4)
      return NS_OK;
    }
    free(*_retval);
  }
  *_retval = nullptr;
  return NS_ERROR_FAILURE;
}

At (1), GetMaxLength() can return -1 (0xffffffff), which then would be used by malloc at (2) to allocate a buffer of size 0, leading to a heap corruption (i.e. a buffer overflow, or nulling of the trailing byte of the preceding heap chunk) at either (3) or/and (4). 

There are also other places in the code base, where GetMaxLength() is used in a similar fashion.

The issue was verified with the latest release code of Firefox ESR.

