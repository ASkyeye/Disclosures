Buffer overflow and infoleak in Oracle VirtualBox crServerDispatchGenProgramsARB

Testing: VirtualBox v5.2.12 x64 
VM: Windows 7 x64
Host OS: Windows 10 x64, April 2018


There is an integer overflow in the VirtualBox Chromium function crServerDispatchGenProgramsARB in the processing of the CR_GENPROGRAMSARB_EXTEND_OPCODE (/VirtualBox-5.2.12/src/VBox/HostServices/SharedOpenGL/crserverlib/server_gentextures.c):

void SERVER_DISPATCH_APIENTRY crServerDispatchGenProgramsARB( GLsizei n, GLuint * ids )
{
    GLuint *local_progs = (GLuint *) crAlloc( n*sizeof( *local_progs) ); // <———— (0) integer overflow
    GLsizei i;
    (void) ids;
    cr_server.head_spu->dispatch_table.GenProgramsARB( n, local_progs ); // <———— (1) out of bounds access

    /* see comments in crServerDispatchGenTextures */
    for (i=0; i<n; ++i)
    {
        GLuint tID = crServerTranslateProgramID(local_progs[i]); // <———— (2) out of bounds read
        while (crStateIsProgramARB(tID))
        {
            cr_server.head_spu->dispatch_table.GenProgramsARB(1, &tID);
            local_progs[i] = tID; // <———— (3) out of bounds write
            tID = crServerTranslateProgramID(tID);
        }
    }

    crServerReturnValue( local_progs, n*sizeof( *local_progs ) ); // <———— (4) send the leaked data to VM
    crFree( local_progs );
}

At line (0), integer overflow can happen, if the `n` variable (provided by the VM) is in the range 0x40000000..0xffffffff. In such case the local_progs buffer allocated by crAlloc will be too small to hold `n` instances of GLuint. Further in the code, at lines (1)-(3), out-of-bounds reads and writes can happen (depending on exact values of `n` versus the size of the `local_progs` buffer). At line (4), the contents of the local_progs buffer is sent back to the VM. Thus it’s possible to leak some entropy and escalate privileges from VM to Host.


See also: 
crash.png - screenshot of a write a/v
VBox.log - crash log from VirtualBox VM 
poc.c - proof of concept code which demonstrates an out of bounds write by default.